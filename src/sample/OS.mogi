{@Random=0;}{@TimeLimit=1800;}{@Kaitougun=False;}
OS 前期末 模擬テスト

OSの基本的な目標はリソースの{Answer=仮想化;}である。プロセスから見た場合、OSや各プロセスが主記憶上の{Answer=物理;}アドレス空間ではなく、独立の{Answer=論理;}アドレス空間を持つことが重要だ。{Answer=論理;}アドレスの{Answer=物理;}アドレスへのマッピングは{Answer=主記憶管理部;Other=MMU;}と呼ばれるハードウェアによって行われる。
理想的なアドレス空間は、
１、大きさが{Answer=無制限;}
２、プロセスごとに{Answer=固有の空間;}を持ち、他のプロセスから{Answer=保護;}される。
３、プログラム部、データ部、スタック部などが{Answer=分離;}している
４、プロセス間でのアドレスの{Answer=共有;}が可能
といった、条件を満たしている。

高級言語で記述されたプログラムでは、{Answer=識別子;}を{Answer=論理;}アドレスに変換する{Answer=ネーミング;}関数、{Answer=論理;}アドレスから{Answer=物理;}アドレスに変換する{Answer=メモリ;}関数、最後に{Answer=物理;}アドレスからメモリの内容へ変換する{Answer=内容;}関数の3つの変換関数が用いられる。特に、{Answer=メモリ;}関数の実行の際の{Answer=オーバーヘッド;}はプログラム実行時の性能に大きな影響を及ぼす。従って、メモリ関数の設計指針としては、
１、{Answer=論理;}アドレスから{Answer=物理;}アドレスへの変換の{Answer=オーバーヘッド;}が少ないこと
２、{Answer=ハードウェア;}が複雑にならないこと
３、プログラマやコンパイラにとって使いやすい{Answer=論理;}アドレス空間を提供すること
が挙げられる。

通常OSでの実行は、CPU内では{Answer=スーパーバイザ;}モードで実行され、ユーザープログラムは{Answer=ユーザー;Other=ユーザ;}モードで実行される。下限レジスタ機構では、プログラムが参照するアドレス(アドレスレジスタ(ADR)に格納)が、下限レジスタ(LL)の示す値より{Answer=小さい;Item=大きい;AnswerNum=2;HeadChar=abc;}場合に割込み処理(例:ユーザプログラムの停止)が行われる。ADRとLLの比較器にはイネーブル入力として{Answer=PSW;}から取得した実行中のモードを用いる。
下限レジスタ機構には、以下の欠点がある。
１、{Answer=1;}つの境界しかない
２、{Answer=プロセス;}によって{Answer=アクセス権;}を変えることができない
この欠点の解決のために、{Answer=ロック/キー機構;Other=ロック／キー機構;}が提案された。この方式ではアドレスは上位部と下位部に分けて仮想化され、主記憶はアドレス{Answer=上位;Item=下位;AnswerNum=1;HeadChar=abc;}部が同一である部分領域に仮想的に分割される。また、分割した領域数と同じ数の要素数を持った{Answer=ロックデータ;}配列を作成し、主記憶の{Answer=領域;Other=ブロック;}ごとのアクセス権を格納しておく。さらに、{Answer=PSW;}には{Answer=実行中のプロセス;}のアクセス権を格納しておく。プログラムの実行時に、参照しようとするアドレスの{Answer=上位;Item=下位;AnswerNum=1;HeadChar=abc;}部をインデックスとしてロックデータ配列を参照し、PSWに格納した自プロセスのアクセス権と比較、相違があれば割込みを行う。これにより、プログラムは参照しようとしているアドレスのアクセス権が自分のアクセス権に見合っているかを知ることができる。

プログラムによる主記憶領域の要求は、そのタイミングによって{Answer=静的な領域要求;}と{Answer=動的な領域要求;}の2つに分類される。前者は{Answer=固定区画;}方式を用いてプロセスに領域を割り当てるが、{Answer=小規模;}なプロセスにとっては無駄の多い領域となることがある。対して後者は{Answer=可変区画;}方式を用いる。しかし、プロセスの生成と消滅を繰り返した結果、{Answer=メモリフラグメンテーション;}という現象が発生する。生じる空き領域は実に全体の{Answer=半分;}にもなることが指摘されている。この現象の解決には{Answer=メモリコンパクション;}を実行しなければならない。
{Answer=可変区画;}方式ではさまざまなプロセスへの領域の割り当て方式がある。
{Answer=ベストフィット;}方式：領域を割り当てたあとの残り領域が一番小さくなる空き領域を割り当てる。かえって{Answer=小さ;}い空き領域が多くなる欠点がある。
{Answer=ファーストフィット;}方式：探索時に最初に見つかった、プロセスからの要求を満たす空き領域を割り当てる方式。アドレスの{Answer=下位;Item=上位;AnswerNum=2;HeadChar=abc;}から探索することで{Answer=上位;Item=下位;AnswerNum=1;HeadChar=abc;}に{Answer=大き;}な空き領域が集まり、色々な大きさの要求にこたえることができる。
{Answer=ワーストフィット;}方式：割り当て後の領域が一番大きくなるように割り当てる。空き領域の大きさが{Answer=均一;}化する。

具体的な空き領域管理方法として、リスト方式がある。先頭アドレス順に挿入した場合、{Answer=ファーストフィット;}方式が実現できる。また、サイズの{Answer=小さい;Other=昇;}順に挿入した場合には{Answer=ベストフィット;}方式が実現できる。また、主記憶の各ブロックに対応した、空き領域かどうかを示す{Answer=配列;}を用意する{Answer=ビットマップ;}方式もあり、アクセスは{Answer=高速;}となるが、空き領域発見のコストが低くなるとは限らない。
ソースプログラムを最終的に{Answer=ロードモジュール;}としてファイルに格納する過程で、{Answer=共有ライブラリ;}のリンク情報を埋め込み、実行時に{Answer=動;}的にリンクさせることで、主記憶の効率的な利用が実現できる。
あるライブラリ関数が複数のプログラムから同時に利用できるとき、{Answer=リエントラント;}性を持つ、という。関数が{Answer=リエントラント;}性を持つためには、「任意の場所で{Answer=中断;Other=プリエンプションが発生;}し、他のプログラムから同一の関数を実行でき、その上実行終了後に{Answer=再開;}できる」必要がある。従って、
１．{Answer=静的;}な変数や{Answer=グローバル;}変数への代入
２．{Answer=固定;}されたメモリ領域への参照
などがあってはならない。また、プログラム本体が{Answer=再配置可能;}(リロケータブル)であることも重要である。

さて、理想的なアドレス空間の条件の1つに{Answer=大きさ;}が物理的に制限されないというものがあった。{Answer=オーバーレイ;}の考え方では、現在実行しているプログラム・関数だけが主記憶上に存在し、その他の関数は{Answer=２次記憶;}に配置するように{Answer=プログラマ;}が制御する方式で主記憶を{Answer=時分割;}する。プログラムカウンタの示す命令しか必要としない{Answer=プログラム内蔵型計算機;}に有効である。しかし、プログラマに余分なコストが必要になり、OS本来の目的に反する結果になる。


